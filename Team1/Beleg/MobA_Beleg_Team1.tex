\documentclass[12pt]{article}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{gensymb}
\usepackage{color}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{svg}
\usepackage{listings}
\usepackage[hidelinks]{hyperref}

\begin{document}

\begin{titlepage}
	\centering
	\includegraphics[width=0.2\textwidth]{Bilder/hszg}\par
	\vspace{1cm}
	{\LARGE Hochschule Zittau/Görlitz \par}
	\vspace{1cm}
	{\Large Mobile Anwendungen\par}
	\vspace{1.5cm}
	{\huge\bfseries FacilityManager \par}
	\vspace{0.75cm}
	{\LARGE Umsetzung als hybride Ionic-App\par}
	\vspace{2cm}
	{\Large Team 1 - Backend\par}
	\vspace{0.75cm}
	{\Large Niklas Merkelt\\Uta Lemke\par}
	\vfill
	{\large 07. Februar 2020\par}
\end{titlepage}

\tableofcontents
\newpage

\begin{abstract}
Im Folgenden geht es um die Implementierung einer Hausmeister-App, von uns FacilityManager getauft, mit der Schadensmeldungen verfasst und abgeschickt, Objektkontrollen anhand von Checklisten durchgeführt und dokumentiert und Informationen über Objekte abgerufen werden können.
\paragraph{Fachlicher Aspekt}
Zu dieser App existierte anfangs bereits ein Prototyp, neu ist allerdings die Zusammenführung aller Funktionen in einer App und die Möglichkeit, Objektkontrollen mithilfe der App durchzuführen. Außerdem war vorgegeben, dass die neue Auflage der Hausmeister-App auch offline funktioniert, was durch eine interne Wrapper-Datenbank für die per RESTFul Webservice erreichbare bereits vorhandene Datenbank realisiert werden sollte. Mehr dazu in Abschnitt \ref{sec:aufg}.
\paragraph{Technologie}
Damit die App auf möglichst vielen Plattformen läuft, haben wir uns am Anfang des Projekts für die Umsetzung mit dem Ionic-Framework entschieden. Dieses ermöglichte uns ein Arbeiten auf hohem Abstraktionsniveau bei gleichzeitigem Handeln der Implementierung auf Android, iOS, als WebApp, Electronapp, etc.
\paragraph{Organisation}
Zu Beginn wurde das Projekt auf drei Arbeitsteams aufgeteilt, ein Team für das Backend, ein Team für den Schadensmeldungsteil der GUI und ein Team für den Objektkontrollenteil der GUI. Hier soll es um den Beitrag des ersten dieser Teams gehen.
\end{abstract}

\section{Aufgabenstellung}\label{sec:aufg} 
Unser Team hatte den Auftrag, sich die folgenden Teile der App zu kümmern:
\paragraph{Das Backend} Eine Datenbankinfrastruktur, die den Zwischenlayer zwischen Webservice und der restlichen App bildet. Hierbei soll sichergestellt werden, dass regelmäßig die aktuellen Daten über Objekte, Mitarbeiter, Schadensmeldungen und Objektkontrollentemplates heruntergeladen werden und der App dann im Offline-Betrieb zur Verfügung stehen. Außerdem soll eine JSON-Schnittstelle bereitgestellt werden, die das Abfragen der lokal gespeicherten Daten erlaubt, ohne dabei direkt auf die per Webservice bereitgestellten Datenbanken zuzugreifen. Auch weitere interne Appdaten sollen nach Bedarf in der internen Datenbank gespeichert werden können, die entsprechende Datenanalyse war dann Aufgabe der anderen beiden Teams.
\paragraph{Die Webserviceschnittstellen} Neben dem Bereitstellen von Daten aus den entsprechenden Webservice, war es auch Aufgabe, eine einheitliche Schnittstelle zur Sendung von Daten an die Webservice einzurichten. Bei Internetverbindung sollen ausstehende Schadensmeldungen und vollendete Objektkontrollen an die entsprechenden Services geschickt werden, ansonten werden auch diese in der internen Datenbankstruktur gespeichert.
\paragraph{Die Authentisierung} Hier geht es darum, dass der Mitarbeiter, der eine Schadensmeldung oder abgeschlossene Objektkontrolle versenden möchte, authentifiziert werden kann. Dafür sollten wir eine Art Loginsystem mitsamt grafischer Oberfläche bauen, in das bei Erstkonfiguration der App der zuständige Administrator den Namen und optionale Berechtigungen des Angestellten eintragen kann. Zu diesen Berechtigungen zählt bis jetzt nur die Objektkontrolle, welche nur einige der Angestellten durchführen. Dieser Bereich soll außerdem passwortgeschützt sein, wobei es dabei weniger um hohe Sicherheitsanforderungen geht, als vielmehr um Prozessoptimierung, der Angestellte selbst soll sich um keine Konfiguration mehr kümmern müssen und können. Als Ergebnis dieser Einstellungen wird angegebene Name des Mitarbeiters bei jedem gesendeten Bericht automatisch eingetragen und die Funktion der Objektkontrolle wird entweder an- oder ausgeschaltet, was auch zu einer Anpassung der GUI führt.
\paragraph{Der Anwendungsrahmen} Zusätzlich wurde unserem Team die Verantwortung übertragen, die Projektstruktur vorzugeben und sich um die Einrichtung der Versionsverwaltung zu kümmern.

\section{Lokale Datenbankinfrastruktur}
\subsection{Umsetzung}
\subsection{Schwierigkeiten}
\subsection{Lösungen}

\section{Kommunikation mit dem Webservice \& Offline-Funktion}
Für die Datenflusskontrolle zwischen App und Datenbank des Kunden wurde uns ein Webservice mit insgesamt fünf Endpunkten zur Verfügung gestellt. Drei davon dienen der Abfrage von Daten. Dabei handelt es sich um Informationen zu Objekten, Informationen zu den Mitarbeitern und Templates für die Objektkontrollen. Mit den anderen beiden Endpunkten werden neue Schadensmeldungen und abgschlossene Objektkontrollen verschickt.\\
Allerdings soll nur mit dem Webservice kommuniziert werden, wenn das Gerät auch wirklich online ist und wenn es überhaupt notwendig ist, die Daten zu synchronisieren. Hierzu wurde zuerst ein NetworkListener implementiert, was sich als schwieriger als gedacht herausstellte, dazu später mehr.\\
Zu Anfang wurde bei jeder Abfrage einer Information diese direkt vom Webservice abgefragt und in aktualisierter Form in die interne Datenbank geschrieben. Um den zusätzlichen Zeitaufwand dieser Synchronisierung zu vermeiden, wird sie nun nur noch bei Start der App, wenn die App aus einem Offline- in einen Onlinezustand kommt und bei manuellem Synchronisierungsaufruf in der GUI durchgeführt. 

\paragraph{}Um die verschiedenen Webserviceendpunkte dem Rest der App zur Verfügung zu stellen, wurden als Interface Angular-Services kreiert. Diese werden dann in jeder Klasse, die die Funktionalität nutzen möchte, injiziert, sodass es von jedem Service nur eine, global verfügbare Instanz gibt.\\
Hierbei gibt es folgende Services: Der \texttt{DamageService}, mit dem neue Schadensmeldungen verschickt werden können, der \texttt{EmployeeService}, mit dem Informationen zu einem gegebenen Mitarbeiter sowie eine Liste aller Mitarbeiter abgefragt werden können, der \texttt{ObjectChecklistService}, mit dem sowohl Templates für Objektkontrollen abgerufen als auch fertiggestellte Objektkontrollen abgeschickt werden können und der \texttt{PropertyService}, mit dem einzelne Objekte mit ID abgefragt sowie Listen von Objekten nach Stadt oder eine Gesamtliste aller Objekte zurückgegeben werden kann.

\paragraph{}
Zur Verwaltung der Onlinefunktionalität der App gibt es außerdem den \texttt{NetworkSendService}, der auf Anfrage von allen Services die Synchronisationsfunktionen zum Abschicken ausstehender Meldungen und Herunterladen der aktuellen Daten vom Webservice ausführt, und den \texttt{NetworkQueryService}, der auf Anfrage den Onlinestatus der App zurückgibt. Usprünglich sollte der \texttt{Networklistener} auch in den \texttt{NetworkSendService} integriert werden, leider bietet Angular aber keine Möglichkeit, einen Hostlistener in einen Service einzubinden. Dafür wird eine Directive benötigt, die dann in jede der GUI-Komponenten eingebunden werden kann, sodass, egal auf welcher Appseite der User sich befindet, das Onlineevent erkannt wird. Damit diese \texttt{NetworkListenerDirective} auch in allen Teilen der App verfügbar ist, wird diese im \texttt{CommonModule} zur Verfügung gestellt. Mit Import dieses im \texttt{module.ts}-Teil einer Appkomponente kann sie dann in den \texttt{ionic-body}-Tag der entsprechenden HTML-Seite eingebunden werden.

\section{Objektexplorer}
\subsection{Umsetzung}
\subsection{Schwierigkeiten}
\subsection{Lösungen}

\section{Nutzerverwaltung}
\subsection{Umsetzung}
\subsection{Schwierigkeiten}
\subsection{Lösungen}

\section{Schreibanteile}
\begin{itemize}
	\item Niklas Merkelt:
	\item Uta Lemke:
\end{itemize}

\end{document}
